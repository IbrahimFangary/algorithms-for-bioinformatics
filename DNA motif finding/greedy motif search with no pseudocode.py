import os

# Function to create a profile matrix based on a list of motifs
def Profile(motifs):
    profile = {}
    t = len(motifs)  # Number of motifs
    k = len(motifs[0])  # Length of each motif
    # Initialize profile matrix with pseudocounts
    for base in 'ACGT':
        profile[base] = [1] * k
    # Populate profile matrix with frequency of each base at each position in motifs
    for i in range(k):
        for motif in motifs:
            profile[motif[i]][i] += 1 / t
    return profile

# Function to find the most probable k-mer in a text given a profile matrix
def ProfileMostProbableKmer(text, k, profile):
    max_prob = -1
    most_probable_kmer = text[:k]
    # Iterate over all k-mers in the text
    for i in range(len(text) - k + 1):
        kmer = text[i:i + k]
        prob = 1
        # Calculate the probability of the k-mer given the profile matrix
        for j in range(k):
            prob *= profile[kmer[j]][j]
        # Update most probable k-mer if current k-mer has higher probability
        if prob > max_prob:
            max_prob = prob
            most_probable_kmer = kmer
    return most_probable_kmer

# Function to calculate the score of a list of motifs
def Score(motifs):
    score = 0
    k = len(motifs[0])  # Length of motifs
    t = len(motifs)  # Number of motifs
    consensus = Consensus(motifs)  # Get consensus motif
    # Calculate score as the sum of Hamming distances between motifs and consensus motif
    for motif in motifs:
        for i in range(k):
            if motif[i] != consensus[i]:
                score += 1
    return score

# Function to generate consensus motif from a list of motifs
def Consensus(motifs):
    k = len(motifs[0])  # Length of motifs
    consensus = ''
    profile = Profile(motifs)  # Create profile matrix
    # Generate consensus motif by selecting the most frequent base at each position
    for i in range(k):
        max_freq = -1
        most_freq_base = ''
        for base in 'ACGT':
            if profile[base][i] > max_freq:
                max_freq = profile[base][i]
                most_freq_base = base
        consensus += most_freq_base
    return consensus

# Function to perform Greedy Motif Search algorithm
def GreedyMotifSearch(Dna, k, t):
    best_motifs = [string[:k] for string in Dna]  # Initialize best motifs as first k-mers in each sequence
    # Iterate over all possible starting positions for the first motif in the first sequence
    for i in range(len(Dna[0]) - k + 1):
        motif1 = Dna[0][i:i + k]  # Get first motif
        motifs = [motif1]  # Initialize list of motifs with first motif
        # Iterate over remaining sequences to find the best motifs
        for j in range(1, t):
            profile = Profile(motifs)  # Create profile matrix
            # Find the most probable k-mer in the current sequence using the profile matrix
            motifs.append(ProfileMostProbableKmer(Dna[j], k, profile))
        # Update best motifs if current motifs have lower score
        if Score(motifs) < Score(best_motifs):
            best_motifs = motifs
    return best_motifs

# Example usage:
d='ATGCTTATCTTTATTATCAAGACCCCGTCCCTGCAGAATTGTAGAGCACCTGTGGGATCCTGGAACTATTCCAAACACCGCGCGTGGAAGCCCTCCGGTATGTGGCTGGGGAAGTATTTTGGAGGGACCAACCGACGAACGAACAGATGCCTGCTG GAACCATAGTTGGAGCCGTGGTCACGCATTGAGGAGACAAGGACGTCGTACGGATAAATGTTCTGTGACCAATCATTGCATCATGGCAGTGCACCGCGCGCGTTCGCATCACAGTCCGTGGGAATGTGGCTGGCTGTGTTCGATATCGCCGCGGTT TTTCCGACATAGGTCTGGAGGTTCGTTCTATCTCTGAAGGCAAGAACGATGGACATCTCTTTGGTTTAGATTGGTTCAGGCCCGCTGTATCCCACCTCTACGATTGCCCTTTCAACCCTCCTTGTTTGCTTTATTGATAAAAGGGATATGAGGCTG GATATGGGACTGTCACTTAGGGACCATGGATCTTTCTAAGTCGAGTTTACGAGCGATCATCAACCGTTAGGATGAATATCCGATTCGTCGGCAAACAAGAGATTGGTACTGTAGCCATGAACAGGTGATAACTACTTAATCATGCTAAGGGGGTGT GAATCAAAGGGGGCGTAAACTCGTAAGAAGATTTGCTGGTCCTCCAATACCAACCTTTGGCTTAGGTGACCTAGGAGGCTAGCCCGGAGAGAAACCGTGTTGAGAGAGAAACCCTGATTTCAAAGGCGGGTGATTAGTATACGTGTCATGAGGCTG GAAATGTGGCTGACATTCCAGCTTTTGGGTCTGTGGTGCCCTTCTGCATAAACAGTTCTCTGGATGCTCACGAGGGCTTGAGGCGCCTGGGCTTTGATTAGACAGACTATCGACAACAACTGTCCAGATGTCCGAAAAAAGGATCCGTTGTTAAGT CCACTGTACTGGTAGACAGCCAGTCATTGCCATACGGATGACGCGAACGGTATAAGGAAGAGGGATCTAGCAACAGACGTTGCAAAACATCCCTGCTCTCGCTCAACTGCGATGAGACTGGCAGGTTTTATTTGTCCCATGACACACAAGCAAGAA CCCATGTACCTTCTTTCCTCTGTCCACATGAAGACACCATACGTGACGTTTTCCGTGATTCGGCGTGAGTCTAATCAATCTTAAGCCATGTGGCTGGTAGGCTTTACCCAGCACAGCGACGCCGCGTACGGTCCGCTCCGATTTAGGTCAATGACT CATACTCAACCTTGGATTACCTATGCGCGTACCAACGCGAGCCAAATAAGTATTGGACAGGTTAAAAGGGGGAGCAGAAAACGTTGGAAAACCATCTTGACAATCGCAGTCATGCGGCTGCCGGAGCACTGACTCAATATCCAACTGGGGCGCGGC CTGCCACCTATCTACATTCAAACACGTGCCTGATACCCATAGTGCATGCGAGACGTATCACATTTCTAAGCGCTGCTAGGGCGTGGAGACACAGTTTCCGAGACCCTTGAACTCCGATTGGGGCGAAAGACACTGACATCCACTGCGATGGGGCTG CCATATATCCATGGGCCCCGATGCGAGGCAATCTAGGAGACTAGTAGCAATTTCATGTCAGACTCTGGATTTGCTATGTGACTGACCCCTTATGGACGTGGACCAGGCGCCATTATCTCCACTCGTCAAAAAGCCTAGGGGGACGCAGACTTTAGT CCATAGGGGGGCAGTCGCGTGCTAATGTGCTTTTTGGGAATGTGACTGGCATTCGGATGTTATGCCACACGGTAGTCTGTAGGCATGCGGCAAGACTGCAGTAAGAACGCATCGGGCTTTGTGCCGGTGGTGGCAGTTGACGAACTGTTGCGAAAG GATGACCAACTTGTGCTTCACACAACCAACTCACGCTGGTTGAGACGCAGCCTTGTAGCGAAGAAACGATTGTAATGAAATGTATTTAATCAGCCTCCTCCGCCCTAAATGATGAGCGTCGGCAAATTACACATTCCCTCTGTGGGTATGAGTCTG ACAGACTTGCCCTGTTCGTTGGTGCAGCGTATATGTGAGACGTATTTAGTCACTCTGGGCGACATGCGACTGAGGCTGGTACAGCCACAACTATCAAGGTGTATTAACGTTGAACGATGTCTCGGTGATATCCTTAATCAGGGCACACGAGTCTTT GCAAAGAAAAAAGCCATGCGTCTGTTGTGGGGCGTCGTTGGTGTCAACCGATCTACCTAGTTAGAGCCGTATCGTCGTCACGACTAGTCTGGGTAGACTATATCGCAATCCTTGGTAATTTGTGACTCAGCGATCAGCGACCCCAATCTTTCTATG AAGTTCATCATAGAACCGGCCAGATTTAGTTCGCCCACTATAAGTCCGTACGCCCTGGAAAGCCACACCTCGGAAATGTGCCTGCCCAAACCCCTGCTGCTCCCGGGCTGAATCTTGCGGAAGAAGTCCCAGTGGCGTGTCCAGTGACGCCTCCGG CGCACAATCATAGGCATGAGCCTGTTTGAATGGTGGCTGTGACCCCCTAATGGCGGAGTATGCTGGCTGAGTTCGCCCATGTGACAATCCATGAGAGTCAAGACAGTAGATTACTGCCGCCCTACTATACTTGAGCATAGAATGCCCCACTCTGCC TGGATCCTGAACTAGAGATTCTGGGAAGCCTGGTACGTCATGAGCCTGGTGAATAGCAGACCACTGCCTAAGTACAGCGGTCAGCGGAGGAGTGCTGTGACGAAACTATGTGGAGGTAAGGTTACATATTTATTTATCTTTCGGTAAGAAACTTGT CAATTAAACGGCGGTATGAGACTGGGGAACTGGCCCGCCCCACCGACAGCCTGCCAATAGAACGTGCGAGGACTGCTCGTATCCAAAAGCGTCCAAGCCAACGTGCTATCGTTTGGAGTCATATTGGGCTGAGAACCTGTCGCGAAGCCACAAGCG CGAGGAACTCCATCACGCCCCCATGGTATGGGCCTGTTAAATGGAATTGTGCTAAAACCTACGAATTCACGGGAGATGGTACAGTTTTAAATGACCTTTGCACCGCTTCAGCCTCCTCTTTTGAAGGTCGGTAGCGTCCCGTGCATAACAGTAACC TGCGTAAAACGCTGGCTTAGGCGGAATTCCCCTATATGGTCACCGAGTGCAATGGGACTGGTTTAGAGAGCAGTAGACTGAACGCAAATAGCATGGTTGAGCCTTCGGAACCCTCGCAGGTGCTCAGGGTTCTCATCGATAACTGGGCCCCGCTAT CTCAGACACGAAGAGATGGGACTGAGTTAAGTACGATTTGATGTTTCGCTTCCGGCATGTTACTGCTGATCAATAACAGTATGATCCTAACCGATATATGTCCGTAGTTTGTCTATGGGCTGTAATAACGGCGGCATACACTCTAAATAGTTCTGA ACCTGAATACTAGCGTGCCAAGCTGCCTACGACATCGGGTACATGAACACCGCAATGGGGTAGACTAAGCGCGGTATGGGACTGTCTAATGCACTGCGGCTACACTAAGGGCTCAAATGTTTTTCATAGGCGAAGCGCTTCGGAGTACACTGTTCG GTGATGCGTCTGTTGGTTCGGTCTGGGGGCCAGTGAACTGTGCCTTTTCAACTATTTCTTACCCACTCACGTTCGCGACCTTCGTGCCACAAATCATACGATACCTAGTCCTGTCGACCCATCAGATCACAGCTGCTCCGGCGTCGTGCCACCTCA GCTGCACGACGTGGTATGCGGCTGCCACGACGCGTTTGGAGAAGCCCGCCAGAGCGGCTACGCCGACATAATTTGATACGATAGTTCGCAGGCGAGGCATCCGTAATAATCGCCGAGTGGGCTTATAGGTGGCCCCCTGAAAACCCCGTCAGGTCG'
Dna = d.split()
k = 12
t = 25
# desktop_path = os.path.join(os.path.join(os.environ['USERPROFILE']), 'Desktop')
# file_path = os.path.join(desktop_path, 'result.txt')

# with open(file_path, 'w') as file:
#     for pos in GreedyMotifSearch(Dna, k, t):
#         file.write(str(pos) + '\n')
print(GreedyMotifSearch(Dna, k, t))
